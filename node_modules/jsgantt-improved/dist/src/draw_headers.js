"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
var events_1 = require("./events");
exports.COLUMN_ORDER = [
    'vShowRes',
    'vShowDur',
    'vShowComp',
    'vShowStartDate',
    'vShowEndDate',
    'vShowPlanStartDate',
    'vShowPlanEndDate',
    'vShowCost',
    'vAdditionalHeaders',
    'vShowAddEntries'
];
exports.draw_header = function (column, i, vTmpRow, vTaskList, vEditable, vEventsChange, vEvents, vDateTaskTableDisplayFormat, vAdditionalHeaders, vFormat, vLangs, vLang, vResources, Draw) {
    console.log('run222', column, i, vTmpRow);
    var vTmpCell, vTmpDiv;
    if ('vShowRes' == column) {
        console.log('SHOWWW', vTmpRow, vTaskList[i]);
        vTmpCell = exports.newNode(vTmpRow, 'td', null, 'gresource');
        var text = exports.makeInput(vTaskList[i].getResource(), vEditable, 'resource', vTaskList[i].getResource(), vResources);
        vTmpDiv = exports.newNode(vTmpCell, 'div', null, null, text);
        var callback = function (task, e) { return task.setResource(e.target.value); };
        events_1.addListenerInputCell(vTmpCell, vEventsChange, callback, vTaskList[i], 'res', Draw, 'change');
        events_1.addListenerClickCell(vTmpCell, vEvents, vTaskList[i], 'res');
    }
    if ('vShowDur' == column) {
        vTmpCell = exports.newNode(vTmpRow, 'td', null, 'gduration');
        var text = exports.makeInput(vTaskList[i].getDuration(vFormat, vLangs[vLang]), vEditable, 'text', vTaskList[i].getDuration());
        vTmpDiv = exports.newNode(vTmpCell, 'div', null, null, text);
        var callback = function (task, e) { return task.setDuration(e.target.value); };
        events_1.addListenerInputCell(vTmpCell, vEventsChange, callback, vTaskList[i], 'dur', Draw);
        events_1.addListenerClickCell(vTmpCell, vEvents, vTaskList[i], 'dur');
    }
    if ('vShowComp' == column) {
        vTmpCell = exports.newNode(vTmpRow, 'td', null, 'gpccomplete');
        var text = exports.makeInput(vTaskList[i].getCompStr(), vEditable, 'percentage', vTaskList[i].getCompVal());
        vTmpDiv = exports.newNode(vTmpCell, 'div', null, null, text);
        var callback = function (task, e) { task.setComp(e.target.value); task.setCompVal(e.target.value); };
        events_1.addListenerInputCell(vTmpCell, vEventsChange, callback, vTaskList[i], 'comp', Draw);
        events_1.addListenerClickCell(vTmpCell, vEvents, vTaskList[i], 'comp');
    }
    if ('vShowStartDate' == column) {
        vTmpCell = exports.newNode(vTmpRow, 'td', null, 'gstartdate');
        var v = utils_1.formatDateStr(vTaskList[i].getStart(), vDateTaskTableDisplayFormat, vLangs[vLang]);
        var text = exports.makeInput(v, vEditable, 'date', vTaskList[i].getStart());
        vTmpDiv = exports.newNode(vTmpCell, 'div', null, null, text);
        var callback = function (task, e) { return task.setStart(e.target.value); };
        events_1.addListenerInputCell(vTmpCell, vEventsChange, callback, vTaskList[i], 'start', Draw);
        events_1.addListenerClickCell(vTmpCell, vEvents, vTaskList[i], 'start');
    }
    if ('vShowEndDate' == column) {
        vTmpCell = exports.newNode(vTmpRow, 'td', null, 'genddate');
        var v = utils_1.formatDateStr(vTaskList[i].getEnd(), vDateTaskTableDisplayFormat, vLangs[vLang]);
        var text = exports.makeInput(v, vEditable, 'date', vTaskList[i].getEnd());
        vTmpDiv = exports.newNode(vTmpCell, 'div', null, null, text);
        var callback = function (task, e) { return task.setEnd(e.target.value); };
        events_1.addListenerInputCell(vTmpCell, vEventsChange, callback, vTaskList[i], 'end', Draw);
        events_1.addListenerClickCell(vTmpCell, vEvents, vTaskList[i], 'end');
    }
    if ('vShowPlanStartDate' == column) {
        vTmpCell = exports.newNode(vTmpRow, 'td', null, 'gplanstartdate');
        var v = vTaskList[i].getPlanStart() ? utils_1.formatDateStr(vTaskList[i].getPlanStart(), vDateTaskTableDisplayFormat, vLangs[vLang]) : '';
        var text = exports.makeInput(v, vEditable, 'date', vTaskList[i].getPlanStart());
        vTmpDiv = exports.newNode(vTmpCell, 'div', null, null, text);
        var callback = function (task, e) { return task.setPlanStart(e.target.value); };
        events_1.addListenerInputCell(vTmpCell, vEventsChange, callback, vTaskList[i], 'planstart', Draw);
        events_1.addListenerClickCell(vTmpCell, vEvents, vTaskList[i], 'planstart');
    }
    if ('vShowPlanEndDate' == column) {
        vTmpCell = exports.newNode(vTmpRow, 'td', null, 'gplanenddate');
        var v = vTaskList[i].getPlanEnd() ? utils_1.formatDateStr(vTaskList[i].getPlanEnd(), vDateTaskTableDisplayFormat, vLangs[vLang]) : '';
        var text = exports.makeInput(v, vEditable, 'date', vTaskList[i].getPlanEnd());
        vTmpDiv = exports.newNode(vTmpCell, 'div', null, null, text);
        var callback = function (task, e) { return task.setPlanEnd(e.target.value); };
        events_1.addListenerInputCell(vTmpCell, vEventsChange, callback, vTaskList[i], 'planend', Draw);
        events_1.addListenerClickCell(vTmpCell, vEvents, vTaskList[i], 'planend');
    }
    if ('vShowCost' == column) {
        vTmpCell = exports.newNode(vTmpRow, 'td', null, 'gcost');
        var text = exports.makeInput(vTaskList[i].getCost(), vEditable, 'cost');
        vTmpDiv = exports.newNode(vTmpCell, 'div', null, null, text);
        var callback = function (task, e) { return task.setCost(e.target.value); };
        events_1.addListenerInputCell(vTmpCell, vEventsChange, callback, vTaskList[i], 'cost', Draw);
        events_1.addListenerClickCell(vTmpCell, vEvents, vTaskList[i], 'cost');
    }
    if ('vAdditionalHeaders' == column && vAdditionalHeaders) {
        for (var key in vAdditionalHeaders) {
            var header = vAdditionalHeaders[key];
            var css = header.class ? header.class : "gadditional-" + key;
            var data = vTaskList[i].getDataObject();
            if (data) {
                vTmpCell = exports.newNode(vTmpRow, 'td', null, "gadditional " + css);
            }
            // const callback = (task, e) => task.setCost(e.target.value);
            // addListenerInputCell(vTmpCell, vEventsChange, callback, vTaskList[i], 'costdate');
            vTmpDiv = exports.newNode(vTmpCell, 'div', null, null, data ? data[key] : '');
        }
    }
    if ('vShowAddEntries' == column) {
        vTmpCell = exports.newNode(vTmpRow, 'td', null, 'gaddentries');
        var button = "<button>+</button>";
        vTmpDiv = exports.newNode(vTmpCell, 'div', null, null, button);
        var callback = function (task, e) {
            console.log('hello');
            vTaskList.push({});
        };
        events_1.addListenerInputCell(vTmpCell, vEventsChange, callback, vTaskList[i], 'addentries', Draw.bind(this));
        events_1.addListenerClickCell(vTmpCell, vEvents, vTaskList[i], 'addentries');
    }
};
exports.draw_bottom = function (column, vTmpRow, vAdditionalHeaders) {
    if ('vShowRes' == column)
        exports.newNode(vTmpRow, 'td', null, 'gspanning gresource', '\u00A0');
    if ('vShowDur' == column)
        exports.newNode(vTmpRow, 'td', null, 'gspanning gduration', '\u00A0');
    if ('vShowComp' == column)
        exports.newNode(vTmpRow, 'td', null, 'gspanning gpccomplete', '\u00A0');
    if ('vShowStartDate' == column)
        exports.newNode(vTmpRow, 'td', null, 'gspanning gstartdate', '\u00A0');
    if ('vShowEndDate' == column)
        exports.newNode(vTmpRow, 'td', null, 'gspanning genddate', '\u00A0');
    if ('vShowPlanStartDate' == column)
        exports.newNode(vTmpRow, 'td', null, 'gspanning gplanstartdate', '\u00A0');
    if ('vShowPlanEndDate' == column)
        exports.newNode(vTmpRow, 'td', null, 'gspanning gplanenddate', '\u00A0');
    if ('vShowCost' == column)
        exports.newNode(vTmpRow, 'td', null, 'gspanning gcost', '\u00A0');
    if (vAdditionalHeaders) {
        for (var key in vAdditionalHeaders) {
            var header = vAdditionalHeaders[key];
            var css = header.class ? header.class : "gadditional-" + key;
            exports.newNode(vTmpRow, 'td', null, "gspanning gadditional " + css, '\u00A0');
        }
    }
    if ('vShowAddEntries' == column)
        exports.newNode(vTmpRow, 'td', null, 'gspanning gaddentries', '\u00A0');
};
exports.draw_list_headings = function (column, vTmpRow, vAdditionalHeaders) {
    if ('vShowRes' == column)
        exports.newNode(vTmpRow, 'td', null, 'gspanning gresource', '\u00A0');
    if ('vShowDur' == column)
        exports.newNode(vTmpRow, 'td', null, 'gspanning gduration', '\u00A0');
    if ('vShowComp' == column)
        exports.newNode(vTmpRow, 'td', null, 'gspanning gpccomplete', '\u00A0');
    if ('vShowStartDate' == column)
        exports.newNode(vTmpRow, 'td', null, 'gspanning gstartdate', '\u00A0');
    if ('vShowEndDate' == column)
        exports.newNode(vTmpRow, 'td', null, 'gspanning genddate', '\u00A0');
    if ('vShowPlanStartDate' == column)
        exports.newNode(vTmpRow, 'td', null, 'gspanning gstartdate', '\u00A0');
    if ('vShowPlanEndDate' == column)
        exports.newNode(vTmpRow, 'td', null, 'gspanning gplanenddate', '\u00A0');
    if ('vShowCost' == column)
        exports.newNode(vTmpRow, 'td', null, 'gspanning gcost', '\u00A0');
    if (vAdditionalHeaders) {
        for (var key in vAdditionalHeaders) {
            var header = vAdditionalHeaders[key];
            var css = header.class ? header.class : "gadditional-" + key;
            exports.newNode(vTmpRow, 'td', null, "gspanning gadditional " + css, '\u00A0');
        }
    }
    if ('vShowAddEntries' == column)
        exports.newNode(vTmpRow, 'td', null, 'gspanning gaddentries', '\u00A0');
};
exports.draw_task_headings = function (column, vTmpRow, vLangs, vLang, vAdditionalHeaders) {
    if ('vShowRes' == column)
        exports.newNode(vTmpRow, 'td', null, 'gtaskheading gresource', vLangs[vLang]['resource']);
    if ('vShowDur' == column)
        exports.newNode(vTmpRow, 'td', null, 'gtaskheading gduration', vLangs[vLang]['duration']);
    if ('vShowComp' == column)
        exports.newNode(vTmpRow, 'td', null, 'gtaskheading gpccomplete', vLangs[vLang]['comp']);
    if ('vShowStartDate' == column)
        exports.newNode(vTmpRow, 'td', null, 'gtaskheading gstartdate', vLangs[vLang]['startdate']);
    if ('vShowEndDate' == column)
        exports.newNode(vTmpRow, 'td', null, 'gtaskheading genddate', vLangs[vLang]['enddate']);
    if ('vShowPlanStartDate' == column)
        exports.newNode(vTmpRow, 'td', null, 'gtaskheading gplanstartdate', vLangs[vLang]['planstartdate']);
    if ('vShowPlanEndDate' == column)
        exports.newNode(vTmpRow, 'td', null, 'gtaskheading gplanenddate', vLangs[vLang]['planenddate']);
    if ('vShowCost' == column)
        exports.newNode(vTmpRow, 'td', null, 'gtaskheading gcost', vLangs[vLang]['cost']);
    if (vAdditionalHeaders) {
        for (var key in vAdditionalHeaders) {
            var header = vAdditionalHeaders[key];
            var text = header.translate ? vLangs[vLang][header.translate] : header.title;
            var css = header.class ? header.class : "gadditional-" + key;
            exports.newNode(vTmpRow, 'td', null, "gtaskheading gadditional " + css, text);
        }
    }
    if ('vShowAddEntries' == column)
        exports.newNode(vTmpRow, 'td', null, 'gtaskheading gaddentries', vLangs[vLang]['addentries']);
};
exports.makeInput = function (formattedValue, editable, type, value, choices) {
    if (type === void 0) { type = 'text'; }
    if (value === void 0) { value = null; }
    if (choices === void 0) { choices = null; }
    if (!value) {
        value = formattedValue;
    }
    if (editable) {
        switch (type) {
            case 'date':
                // Take timezone into account before converting to ISO String
                value = value ? new Date(value.getTime() - (value.getTimezoneOffset() * 60000)).toISOString().split('T')[0] : '';
                return "<input class=\"gantt-inputtable\" type=\"date\" value=\"" + value + "\">";
            case 'resource':
                if (choices) {
                    var found = choices.find(function (c) { return c.id == value || c.name == value; });
                    if (found) {
                        value = found.id;
                    }
                    else {
                        choices.push({ id: value, name: value });
                    }
                    return "<select>" + choices.map(function (c) { return "<option value=\"" + c.id + "\" " + (value == c.id ? 'selected' : '') + " >" + c.name + "</option>"; }).join('') + "</select>";
                }
                else {
                    return "<input class=\"gantt-inputtable\" type=\"text\" value=\"" + (value ? value : '') + "\">";
                }
            case 'cost':
                return "<input class=\"gantt-inputtable\" type=\"number\" max=\"100\" min=\"0\" value=\"" + (value ? value : '') + "\">";
            default:
                return "<input class=\"gantt-inputtable\" value=\"" + (value ? value : '') + "\">";
        }
    }
    else {
        return formattedValue;
    }
};
exports.newNode = function (pParent, pNodeType, pId, pClass, pText, pWidth, pLeft, pDisplay, pColspan, pAttribs) {
    if (pId === void 0) { pId = null; }
    if (pClass === void 0) { pClass = null; }
    if (pText === void 0) { pText = null; }
    if (pWidth === void 0) { pWidth = null; }
    if (pLeft === void 0) { pLeft = null; }
    if (pDisplay === void 0) { pDisplay = null; }
    if (pColspan === void 0) { pColspan = null; }
    if (pAttribs === void 0) { pAttribs = null; }
    var vNewNode = pParent.appendChild(document.createElement(pNodeType));
    if (pAttribs) {
        for (var i = 0; i + 1 < pAttribs.length; i += 2) {
            vNewNode.setAttribute(pAttribs[i], pAttribs[i + 1]);
        }
    }
    if (pId)
        vNewNode.id = pId; // I wish I could do this with setAttribute but older IEs don't play nice
    if (pClass)
        vNewNode.className = pClass;
    if (pWidth)
        vNewNode.style.width = (isNaN(pWidth * 1)) ? pWidth : pWidth + 'px';
    if (pLeft)
        vNewNode.style.left = (isNaN(pLeft * 1)) ? pLeft : pLeft + 'px';
    if (pText) {
        if (pText.indexOf && pText.indexOf('<') === -1) {
            vNewNode.appendChild(document.createTextNode(pText));
        }
        else {
            vNewNode.insertAdjacentHTML('beforeend', pText);
        }
    }
    if (pDisplay)
        vNewNode.style.display = pDisplay;
    if (pColspan)
        vNewNode.colSpan = pColspan;
    return vNewNode;
};
/**
 *
 *
 *
 *       COLUMN_ORDER.forEach(column => {
        if (this[column] == 1) {
          draw_list_headings.bind(this)(column, vTmpRow);
        }
      });

       COLUMN_ORDER.forEach(column => {
        if (this[column] == 1) {
          draw_task_headings.bind(this)(column, vTmpRow);
        }
      });

         COLUMN_ORDER.forEach(column => {
            if (this[column] == 1) {
              draw_header.bind(this)(column, i, vTmpRow, makeInput);
            }
          });

              COLUMN_ORDER.forEach(column => {
        if (this[column] == 1) {
          draw_bottom.bind(this)(column, vTmpRow);
        }
      });
 */ 
//# sourceMappingURL=draw_headers.js.map